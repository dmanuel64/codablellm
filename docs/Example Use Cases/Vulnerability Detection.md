# Vulnerability Detection

## Overview

In this example, we use CodableLLM to generate a synthetic vulnerability dataset focused on buffer overflows.

While real-world vulnerability datasets are significantly more complex — often requiring advanced static analysis, taint tracking, and manual verification — this demonstration illustrates how CodableLLM can be used to rapidly create training data for LLMs that specialize in vulnerability detection.


## Creating The Vulnerability Dataset

In this demonstration, we locate array accesses in C source code and inject a vulnerability by adding `+ 1` to each index. This simple transformation simulates unsafe memory access and can help train models to recognize patterns of potentially exploitable buffer overflows.

We will use the `DecompiledCodeDataset` generation pipeline with the `temp-append` mode, which automatically includes both the original (benign) and transformed (vulnerable) functions in the dataset. The dataset will consist of both source code and decompiled function pairs, making it ideal for both source-level and binary-level vulnerability detection research.

```python
from codablellm import compile_dataset, DecompiledCodeDatasetConfig, ExtractorConfig, \
    SourceFunction

def add_one_to_array_access(source: SourceFunction) -> SourceFunction: ...
    # Logic to add + 1 to array accesses and potentially create a buffer overflow vulnerability

dataset = compile_dataset(
    'path/to/demo-c-repo',
    [
        'path/to/demo-c-repo/main_app',
        'path/to/demo-c-repo/tool',
    ],
    'make',
    dataset_config=DecompiledCodeDatasetConfig(
        extract_config=ExtractConfig(
            transform=add_one_to_array_access
        )
        generation_mode='temp-append' # Include both benign & vulnerable examples
    )
)

dataset.save_as('vulnerability_dataset.csv')
```

## Dataset Contents

Inside `vulnerability_dataset.csv`, each function will be included twice:

- The original, benign version
- The transformed version with a potential buffer overflow vulnerability injected

In addition to source-level transformations, the dataset will also contain decompiled representations of both the benign and vulnerable versions. This makes the dataset valuable for training models on both source code vulnerability detection and binary analysis tasks.

### Example

Benign Function Source Code:

```c
void copy_array(int *arr, int size) {
	for (int i = 0; i < size; i++) {
		arr[i] = i;
	}
}
```

Vulnerable Function Source Code:

```c
void copy_array(int *arr, int size) {
	for (int i = 0; i < size; i++) {
		arr[i + 1] = i;
	}
}
```

## Implications

By generating datasets that include both safe and unsafe examples at both the source and decompiled levels:

- Models can learn to distinguish between benign and vulnerable code patterns in both code and binaries.
- Fine-tuned models can be used to power automated vulnerability scanners and suggest secure coding fixes.
- This workflow showcases how CodableLLM can accelerate research and development in AI-powered cybersecurity tooling.
